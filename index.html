<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opencv JS</title>
    <script async src="js/opencv.js" onload="openCvReady();"></script>
    <script src="js/utils.js"></script>
</head>

<body>
    <video id="cam_input" height="480" width="640" hidden></video>
    <canvas id="canvas_output"></canvas>
</body>
<script>
    const biggestContour = (contours, minArea = 5000, maxArea = 50000, epsilonFactor = 0.01, loop = false) => {
        let biggest;
        let max_area = 0
        let poly = new cv.MatVector();
        let cnt = new cv.Mat();
        let tmp = new cv.Mat();
        for (let i = 0; i < contours.size(); i++) {
            cnt = contours.get(i);
            area = cv.contourArea(cnt)
            if (area < minArea || area > maxArea)
                continue;

            let peri = cv.arcLength(cnt, true)
            // You can try more different parameters
            while (tmp.empty() || loop) {
                cv.approxPolyDP(cnt, tmp, epsilonFactor * peri, true)
                epsilonFactor += 0.005
                if (area > max_area && tmp.total() === 4) {
                    biggest = tmp
                    max_area = area
                    loop = false
                }
                if (epsilonFactor > 0.2)
                    loop = false
            }

        }
        if (biggest) {
            // cnt = contours.get(biggest);
            poly.push_back(biggest);
        }
        cnt.delete(); tmp.delete();
        return { poly, max_area }
    }
</script>
<script type="text/JavaScript">
    function openCvReady() {
        cv['onRuntimeInitialized'] = () => {
            let video = document.getElementById("cam_input"); // video is the id of video tag
            navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        width: { min: 1024, ideal: 1280, max: 1920 },
                        height: { min: 576, ideal: 720, max: 1080 },
                        facingMode: { exact: "environment" }
                    }
                })
                .then(function (stream) {
                    video.srcObject = stream;
                    video.play();
                })
                .catch(function (err) {
                    console.log("An error occurred! " + err);
                });
            let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
            let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
            let gray = new cv.Mat();
            let blur = new cv.Mat();
            let canny = new cv.Mat();
            let dilate = new cv.Mat();
            let erode = new cv.Mat();
            let cap = new cv.VideoCapture(cam_input);
            let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
            let faces = new cv.RectVector();
            let classifier = new cv.CascadeClassifier();
            let utils = new Utils('errorMessage');
            let ksize = new cv.Size(5, 5);
            let anchor = new cv.Point(-1, -1);
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            // let color = new cv.Scalar(87,1,244);
            let color = new cv.Scalar(Math.round(Math.random() * 255),
                          Math.round(Math.random() * 255),
                             Math.round(Math.random() * 255))
            // let faceCascadeFile = 'haarcascade_frontalface_default.xml'; // path to xml
            // utils.createFileFromUrl(faceCascadeFile, faceCascadeFile, () => {
            //     classifier.load(faceCascadeFile); // in the callback, load the cascade from file 
            // });
            const FPS = 30;
            function processVideo() {
                let begin = Date.now();
                cap.read(src);
                src.copyTo(dst);

                let maxArea = dst.matSize[0] * dst.matSize[1] * 0.9
                let minArea = dst.matSize[0] * dst.matSize[1] * 0.1
                cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.GaussianBlur(gray, blur, ksize, 0.4)
                cv.threshold(blur, blur, 40, 255,  cv.THRESH_BINARY | cv.THRESH_OTSU);
                cv.Canny(blur, canny, 75, 100, 5, true);
                cv.dilate(canny, dilate, kernel, anchor, 1)
                // cv.erode(dilate, erode, kernel, anchor, 1)
                cv.findContours(dilate, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);



                // let maxArea = dst.matSize[0] * dst.matSize[1] * 0.9
                // let minArea = dst.matSize[0] * dst.matSize[1] * 0.1
                // cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY, 0);
                // cv.GaussianBlur(gray, blur, ksize, 1.4)
                // cv.threshold(blur, blur, 100, 200, cv.THRESH_BINARY);
                // let contours = new cv.MatVector();
                // let hierarchy = new cv.Mat();
                // let poly = new cv.MatVector();
                // cv.findContours(blur, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                // // approximates each contour to polygon
                // for (let i = 0; i < contours.size(); ++i) {
                //     let cnt = contours.get(i);
                //     area = cv.contourArea(cnt)
                //     if (area < minArea || area > maxArea)
                //         continue;
                //     let tmp = new cv.Mat();
                //     let peri = cv.arcLength(cnt, true)
                //     // You can try more different parameters
                //     cv.approxPolyDP(cnt, tmp, 0.03 * peri , true);
                //     if (tmp.total() === 4)
                //         poly.push_back(tmp);
                //     cnt.delete(); tmp.delete();
                // }
                // // draw contours with random Scalar
                // for (let i = 0; i < poly.size(); ++i) {
                //     let color = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255),
                //                             Math.round(Math.random() * 255));
                //     cv.drawContours(dst, poly, i, color, 1, 8, hierarchy, 0);
                // }


                // cv.imshow("canvas_output", dst);


                const { poly, max_area } = biggestContour(contours, minArea, maxArea, 0.03, false)
                if(max_area !== 0)
                    cv.drawContours(dst, poly, -1, color, 5);


                cv.imshow("canvas_output", dst);
                // schedule next one.
                let delay = 1000 / FPS - (Date.now() - begin);
                setTimeout(processVideo, delay);
            }
            // schedule first one.
            setTimeout(processVideo, 0);
        };
    }
</script>

</html>